# frozen_string_literal: true


require 'set'
require 'autoc'


module AutoC


  # :nodoc:
  module EntityContainer

    def entities = @entities ||= ::Set.new

    def <<(entity)
      entities << entity
      self
    end

  end # EntityContainer


  class Module

    # :nodoc:
    class Builder < ::Array

      attr_reader :complexity

      def initialize
        @complexity = 0
        super
      end

      def <<(obj)
        @complexity += (s = obj.to_s).size
        super(s)
      end

    end

    include EntityContainer

    CAP = "/* Automagically generated by AutoC #{AutoC::VERSION} */"

    attr_reader :name

    attr_reader :source_count

    def initialize(name) = @name = name

    def header = @header ||= Header.new(self)

    def sources = @sources ||= (1..source_count).collect { |i| Source.new(self, i) }

    def render
      distribute_entities
      header.render
      sources.each(&:render)
    end

    private def total_entities
      @total_entities ||= begin
        set = ::Set.new
        entities.each { |e| set.merge(e.total_dependencies) }
        set
      end
    end

    private def distribute_entities
      header.entities.merge(total_entities)
      if @source_count.nil?
        if @source_complexity_threshold.nil?
          @source_count = 1
        else
          @source_count = (total_entities.sum(&:complexity).to_f / @source_complexity_threshold).ceil
        end
      end
      total_entities.each do |e|
        sources.sort! { |lt, rt| lt.complexity <=> rt.complexity }
        sources.first << e
      end
    end

    def self.render(name, &code)
      m = Module.new(name)
      yield(m) if block_given?
      m.render
    end

  end # Module


  class Module::Header

    include EntityContainer

    attr_reader :module

    def file_name = @file_name ||= "#{self.module.name}_auto.h"

    def initialize(m)
      @module = m
      @tag = "#{self.module.name}_auto_h".upcase
    end

    def render
      s = stream
      prologue(s)
      entities.to_a.sort.each { |e| e.interface.each { |x| s << x } }
      epilogue(s)
    ensure
      s.close
      @stream = nil
    end

    private

    def prologue(stream)
      stream << %{
        #{Module::CAP}
        #ifndef #{@tag}
        #define #{@tag}
      }
    end

    def epilogue(stream)
      stream << %{
        #endif
      }
    end

    def stream = @stream ||= File.new(file_name, 'w')

  end # Header


  class Module::Source

    include EntityContainer

    attr_reader :module

    attr_reader :complexity

    attr_reader :index

    def file_name = @file_name ||= self.module.source_count < 2 ? "#{self.module.name}_auto.c" : "#{self.module.name}_auto#{index}.c"

    def initialize(m, index)
      @module = m
      @complexity = 0
      @index = index
    end

    def render
      s = stream
      prologue(s)
      total_entities = ::Set.new
      entities.each { |e| total_entities.merge(e.total_dependencies) }
      total_entities.to_a.sort.each { |e| e.forward_declarations.each { |x| s << x } }
      entities.to_a.sort.each { |e| e.implementation.each { |x| s << x } }
    ensure
      s.close
      @stream = nil
    end

    def <<(entity)
      @complexity += entity.complexity unless entities.include?(entity)
      super
    end

    private

    def prologue(stream)
      stream << %{
        #{Module::CAP}
        #include "#{self.module.header.file_name}"
      }
    end

    def stream = @stream ||= File.new(file_name, 'w')

  end # Source


  module Entity

    # A set of the entity's immediate dependencies
    def dependencies = @dependencies ||= ::Set.new

    # Return the entire entity dependency set staring with self
    def total_dependencies = @total_dependencies ||= collect_dependencies(::Set.new)

    protected def collect_dependencies(set)
      unless set.include?(self)
        set << self
        dependencies.each { |d| d.collect_dependencies(set) }
      end
      set
    end

    def position
      @position ||=
        begin
          p = 0
          total_dependencies.each do |d|
            x = relative_position(d)
            p = x if p < x
          end
          p
        end
    end

    def <=>(other) = position <=> other.position

    def complexity = forward_declarations.complexity + implementation.complexity # Interface part is not considered as it is shared across the sources

    def interface
      @interface ||= begin
        render_interface(stream = Module::Builder.new)
        stream
      end
    end

    def forward_declarations
      @forward_declarations ||= begin
        render_forward_declarations(stream = Module::Builder.new)
        stream
      end
    end

    def implementation
      @implementation ||= begin
        render_implementation(stream = Module::Builder.new)
        stream
      end
    end
  
  private

    def relative_position(other) = equal?(other) ? 0 : other.position + 1

    ### Overridable rendering methods

    def render_interface(stream) = nil

    def render_forward_declarations(stream) = nil

    def render_implementation(stream) = nil

  end # Entity


  # Plain C side code block
  class Code

    include Entity

    def initialize(interface: nil, implementation: nil)
      @interface_ = interface
      @implementation_ = implementation
    end

  private

    def render_interface(stream)
      stream << @interface_ unless @interface_.nil?
    end

    def render_implementation(stream)
      stream << @implementation_ unless @implementation_.nil?
    end

  end # Code


end