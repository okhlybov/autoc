# frozen_string_literal: true


require 'set'
require 'autoc'


module AutoC


  # :nodoc:
  module EntityContainer

    def entities = @entities ||= ::Set.new

    def <<(entity)
      entities << entity
      self
    end

  end # EntityContainer


  class Module

    # :nodoc:
    class Builder < ::Array

      attr_reader :complexity

      def initialize
        @complexity = 0
        super
      end

      def <<(obj)
        @complexity += (s = obj.to_s).size
        super(s)
      end

    end

    include EntityContainer

    CAP = "/* Automagically generated by AutoC #{AutoC::VERSION} */"

    attr_reader :name

    attr_accessor :source_count

    attr_accessor :source_threshold

    def initialize(name) = @name = name

    def header = @header ||= Header.new(self)

    def sources = @sources ||= (1..source_count).collect { |i| Source.new(self, i) }

    def render
      distribute_entities
      header.render
      sources.each(&:render)
    end

    def total_entities
      @total_entities ||= begin
        set = ::Set.new
        entities.each { |e| set.merge(e.total_references) }
        set
      end
    end

    private def distribute_entities
      header.entities.merge(total_entities)
      if source_count.nil?
        @source_count = source_threshold.nil? ? 1 : (total_entities.sum(&:complexity).to_f / source_threshold).ceil
      end
      total_entities.each do |e|
        sources.sort! { |lt, rt| lt.complexity <=> rt.complexity }
        sources.first << e
      end
    end

    def self.render(name, &code)
      m = Module.new(name)
      yield(m) if block_given?
      m.render
    end

  end # Module


  class Module::Header

    include EntityContainer

    attr_reader :module

    def file_name = @file_name ||= "#{self.module.name}_auto.h"

    def tag = @tag ||=  "#{self.module.name}_auto_h".upcase

    def initialize(m) = @module = m

    def render
      s = stream
      render_prologue(s)
      entities.to_a.sort.each { |e| e.interface.each { |x| s << x } }
      render_epilogue(s)
    ensure
      s.close
      @stream = nil
    end

  private

    def render_prologue(stream)
      stream << %{
        #{Module::CAP}
        #ifndef #{tag}
        #define #{tag}
      }
    end

    def render_epilogue(stream)
      stream << %{
        #endif
      }
    end

    def stream = @stream ||= File.new(file_name, 'w')

  end # Header


  class Module::Source

    include EntityContainer

    attr_reader :module

    attr_reader :complexity

    attr_reader :index

    def file_name = @file_name ||= self.module.source_count < 2 ? "#{self.module.name}_auto.c" : "#{self.module.name}_auto#{index}.c"

    def initialize(m, index)
      @module = m
      @complexity = 0
      @index = index
    end

    def render
      s = stream
      render_prologue(s)
      total_entities = ::Set.new
      entities.each { |e| total_entities.merge(e.total_references) }
      total_entities.to_a.sort.each { |e| e.forward_declarations.each { |x| s << x } }
      entities.to_a.sort.each { |e| e.implementation.each { |x| s << x } }
    ensure
      s.close
      @stream = nil
    end

    def <<(entity)
      @complexity += entity.complexity unless entities.include?(entity)
      super
    end

  private

    def render_prologue(stream)
      stream << %{
        #{Module::CAP}
        #include "#{self.module.header.file_name}"
      }
    end

    def stream = @stream ||= File.new(file_name, 'w')

  end # Source


  module Entity

    include ::Comparable

    # A set of the entity's immediate references which, unlike dependencies, do not enforce the entities relative ordering
    def references = @references ||= ReferenceSet.new

    # Return the entire entity's reference set staring with self
    def total_references = @total_references ||= collect_references(::Set.new)

    # A set of the entity's immediate dependencies which enforce the entities relative ordering
    def dependencies = @dependencies ||= DependencySet.new(self)

    # Return the entire entity's dependency set staring with self
    def total_dependencies = @total_dependencies ||= collect_dependencies(::Set.new)

    protected def collect_references(set)
      unless set.include?(self)
        set << self
        references.each { |x| x.collect_references(set) }
      end
      set
    end

    protected def collect_dependencies(set)
      unless set.include?(self)
        set << self
        dependencies.each { |x| x.collect_dependencies(set) }
      end
      set
    end

    def <=>(other) = position <=> other.position

    # Compute the entity's relative position with respect to its dependencies
    def position = @position ||= begin
      p = 0
      # This code goes into infinite recursion on circular dependency
      # which must be resolved manually with Entity#references
      total_dependencies.each do |d|
        unless equal?(d)
          dp = d.position
          p = dp if p < dp # p <- max(p, dp)
        end
      end
      p + 1 # Arrange entity to follow all its dependencies
    end

    def complexity = forward_declarations.complexity + implementation.complexity # Interface part is not considered as it is shared across the sources

    def interface
      @interface ||= begin
        render_interface(stream = Module::Builder.new)
        stream
      end
    end

    def forward_declarations
      @forward_declarations ||= begin
        render_forward_declarations(stream = Module::Builder.new)
        stream
      end
    end

    def implementation
      @implementation ||= begin
        render_implementation(stream = Module::Builder.new)
        stream
      end
    end
  
  private

    ### Overridable rendering methods

    def render_interface(stream) = nil

    def render_forward_declarations(stream) = nil

    def render_implementation(stream) = nil

  end # Entity


  Entity::ReferenceSet = ::Set


  # :nodoc:
  class Entity::DependencySet < ::Set

    def initialize(entity)
      super()
      @entity = entity
    end

    def <<(x)
      @entity.references << x # Each dependency is also registered as a reference
      super
    end

  end # DependencySet


  # Helper class to represent plain C side code block
  class Code

    include Entity

    def initialize(interface: nil, implementation: nil, definitions: nil)
      @interface_ = interface
      @definitions_ = definitions
      @implementation_ = implementation
    end

    def inspect = "... <#{self.class}>"

  private

    def render_interface(stream)
      stream << @interface_ unless @interface_.nil?
    end

    def render_implementation(stream)
      stream << @implementation_ unless @implementation_.nil?
    end

    def render_forward_declarations(stream)
      stream << @definitions_ unless @definitions_.nil?
    end

  end # Code


  # Helper class to inject a system-wide header into the C side interface part of the module
  class SystemHeader < AutoC::Code
    def initialize(header)
      super interface: %{
        #include <#{header}>
      }
    end
  end # SystemHeader


end