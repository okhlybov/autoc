\documentclass[a4paper]{article}


\clubpenalty=10000
\widowpenalty=10000


\usepackage{geometry}
\geometry{a4paper,margin=15mm,bindingoffset=15mm,heightrounded}


\usepackage{listings}
\lstloadlanguages{Ruby,C,bash}
\lstset{commentstyle=\itshape,stringstyle=\bfseries}


\newcommand{\autoc}{\emph{AutoC}}


\newcommand{\R}{\emph{Ruby}}


\newcommand{\C}{\emph{C}}


\newcommand{\Cpp}{\emph{C++}}


\newcommand{\Java}{\emph{Java}}


\lstnewenvironment{rs}{\lstset{language=Ruby,frame=tlbr,basicstyle=\small}}{}


\lstnewenvironment{cs}{\lstset{language=C,frame=tlbr,basicstyle=\small}}{}


\lstnewenvironment{bs}{\lstset{language=bash,frame=tlbr,basicstyle=\small}}{}



\newcommand{\st}{\underline{type}}
\newcommand{\et}{\underline{element-type}}
\newcommand{\kt}{\underline{key-type}}
\newcommand{\vt}{\underline{value-type}}


\newcommand{\sv}{\emph{self}}
\newcommand{\ev}{\emph{element}}
\newcommand{\kv}{\emph{key}}
\newcommand{\vv}{\emph{value}}


\newcommand{\meth}[1]{#1}


\begin{document}


\title{\autoc\ user's manual}
\author{Oleg A. Khlybov}


\maketitle


\part{Introduction}


\autoc\ is a host of \R\ modules related to automatic \C\ source code generation.


\newcommand{\codebuilder}{\emph{CodeBuilder}}
\part{\codebuilder\ module}


This module contains a facility to help generate \C\ modules.


\newcommand{\datastructbuilder}{\emph{DataStructBuilder}}
\part{\datastructbuilder\ module}


This module contains generators which create strongly-typed \C\ data containers similar to those found in \Cpp\ \emph{STL} library: \emph{vector}, \emph{list}, \emph{set}, \emph{map}, and more.


\section{Quick start}


Suppose one needs a \C\ set container which operates on \lstinline[language=C++]{int} data type.
In \Cpp\ world this would be a \lstinline[language=C++]{std::set<int>} type (with the difference that \lstinline[language=C++]{std::set<>} is a tree-based set while \autoc\ currently contains generator for a hash-based set implementation only).


\begin{enumerate}


\item Create a \R\ definition file \emph{containers.rb}:


\begin{rs}
require "autoc/data_struct_builder"

Int = {:type=>"int"}

CodeBuilder::CModule.generate!("containers") do |m|
	m << DataStructBuilder::HashSet.new("IntSet", Int)
end
\end{rs}


The above file contains \R\ code which instructs to generate the set data structure \emph{IntSet} and put generated \C\ code into specific \C\ compilation unit named \emph{containers}.



\item Generate \C\ source files:


\lstinline[language=bash]!> ruby containers.rb!


Provided that \autoc\ files are somewhere in the \R\ path, the above command will output two \C\ files which consitiute the compilation unit \emph{containers}: the interface file \emph{containers\_auto.h} and the implementation file \emph{containers\_auto.c}.


\item Create main \C\ source file \emph{main.c}:


\begin{cs}
#include <stdio.h>

#include "containers_auto.h"

int main(int argc, char** argv) {
	IntSet set;
	IntSetCtor(&set);
	IntSetPut(&set, 0);
	IntSetPut(&set, 1);
	IntSetPut(&set, 0);
	printf("size(set)=%d\n", IntSetSize(&set));
	IntSetDtor(&set);
	return 0;
}
\end{cs}


The code above creates a set container \emph{set} on stack, puts three integer values into it, prints the number of elements the set actually contains and finally destroys the container.


\item Build the executable:


\lstinline[language=bash]!> cc -o runme main.c containers_auto.c!


On successful execution the above command will produce the executable \emph{runme} with defined logic.


\item Run the executable:


\lstinline[language=bash]!> runme!


Correct output for this program will be 
\begin{verbatim}
size(set)=2
\end{verbatim}
since the set rejects inclusion of duplicate values (in the above case it's \emph{0}).


\end{enumerate}


\section{Generated \C\ code}


\subsection{Naming conventions}


Every generated data container named \emph{type} on the \C\ side comprises of the opaque \C\ struct named \emph{type} (referred to as \st\ in this manual) accompanied by a number of \C\ functions with their names prefxed by \emph{type}, which define a set operations on that data container.
For example, a set of integers named \emph{IntSet} will be represented by the generated \C\ struct \lstinline[language=C]!struct IntSet {...}! and \C\ functions \lstinline[language=C]!void IntSetCtor(...)!, \lstinline[language=C]!void IntSetDtor(...)! etc.

The data container's \C\ element type for all data structures but the mapping will be referred to as \et, the key type and the value type for the mapping will be referred to as \kt\ and \vt, respectively.


\subsection{Construction and destruction}


A data container may be created either on stack or in heap.
For the former case, a construction/destruction is performed by a \meth{\st Ctor()} / \meth{\st Dtor()} pair of functions while for the latter its \meth{\st New()} / \meth{\st Destroy()}.
There may be additional container-specific constructors described in the respective sections.

All generated data structures are reference-counted when allocated on heap.
This means that the pointers may be aliased, passed in and out of functions etc.


\subsection{Iteration}


All generated data structures have built-in iteration capability.
The \autoc's iterators are modeled after the \Java's iterators.
The current implementation is fairly simple and is not designed for the iterator objects to be passed around, shared etc.
Moreover, the data structures \emph{must not} be modified or destroyed from within the iteration loop.
While alterations of some data structures (notably \emph{lists}) are known not to invalidate the active iterators, this does not hold true in general and must be avoided.


The code snippet below demonstrates the typical iterator usage scenario:

\begin{cs}
...
IntSetIt it;
IntSetItCtor(&it, &set);
while(IntSetItHasNext(&it)) {
	int value = IntSetItNext(&it);
	...
}
...
\end{cs}


The usual considerations apply to the order the iterated elements come in: \emph{vectors} and \emph{lists} are the ordered containers while \emph{sets} and \emph{maps} are not.


%----------------------------------------------------------------------------------------------------------------------


\newcommand{\Vector}{\emph{Vector}}
\section{\Vector\ container}


\Vector\ data structure is a simple 0-based resizable array similar to \Cpp\ \lstinline[language=C++]{std::vector<>}.


\subsection{\Vector\ interface}


\begin{itemize}


\item \meth{void \st Ctor(\st*\ \sv, size\_t \emph{size})}


Constructs the container with \emph{size} elements.
The valid index range will be [0, \emph{size}).
The elements are initialized with default constructor.


\item \meth{void \st Dtor(\st*\ \sv)}


Destroys the container along with all contained elements.


\item \meth{\st* \st New(size\_t \emph{size})}


Returns a new heap-allocated container constructed with \meth{\st Ctor()}.


\item \meth{void \st Destroy(\st* \sv)}


Frees the heap-allocated container destroying all contained elements.


\item \meth{\st* \st Assign(\st* \sv)}


\emph{Should be used on heap-allocated containers only.}


\item \meth{size\_t \st Size(\st* \sv)}


Returns the number of elements in the container.


\item \meth{int \st Within(\st* \sv, size\_t \emph{index})}


Returns non-zero value when \emph{index} is a valid index, that is \emph{index} $\in$ [0, \meth{\st Size(\sv)}), and zero value otherwise.


\item \meth{void \st Resize(\st* \sv, size\_t \emph{new\_size})}


Resizes the container to have a new size \emph{new\_size}.
The new size may be either larger or smaller than the old one.
Upon resizing the extra elements which to not fall into new valid range [0, \emph{new\_size}) are destroyed and the missing elements are created with default constructor.


\item \meth{\et\ \st Get(\st* \sv, size\_t \emph{index})}


Returns the element contained at the valid index \emph{index} without releasing it (that is, the element returned will still be owned by the container).
\emph{It is a run-time error to get value at the index outside valid range.}


\item \meth{void \st Set(\st* \sv, size\_t \emph{index}, \et\ \ev)}


Sets the new value \ev\ at the valid index \emph{index}.
\emph{It is a run-time error to set value at the index outside valid range.}
The previously contained element at that index is destroyed.
The container takes ownership over the element \ev.


\end{itemize}



%----------------------------------------------------------------------------------------------------------------------


\newcommand{\List}{\emph{List}}
\section{\List\ container}


\List\ data structure is a singly-linked list which supports insertion and removal operations at one end in a manner of \emph{LIFO} stack.


\subsection{\List\ interface}


\begin{itemize}


\item \meth{void \st Ctor(\st*\ \sv)}


Constructs empty container.


\item \meth{void \st Dtor(\st*\ \sv)}


Destroys the container along with all contained elements.


\item \meth{\st* \st New(void)}


Returns a new heap-allocated container constructed with \meth{\st Ctor()}.


\item \meth{void \st Destroy(\st* \sv)}


Frees the heap-allocated container destroying all contained elements.


\item \meth{\st* \st Assign(\st* \sv)}


\emph{Should be used on heap-allocated containers only.}


\item \meth{size\_t \st Size(\st* \sv)}


Returns the number of elements in the container.


\item \meth{int \st Empty}(\st* \sv)


Returns non-zero value if container is empty (i.e. contains no elements) and zero value otherwise.


\item \meth{void \st Prune}(\st* \sv)


Removes and destroys all contained elements effectively emptying the container.


\item \meth{\et\ \st Get(\st* \sv)}


Returns top element of a non-empty container (i.e. the last one added according to the \emph{LIFO} concept).
\emph{It is a run-time error to get top element of an empty container.}
Container retains the ownership over the element returned.


\item \meth{void \st Add(\st* \sv, \et\ \ev)}


Adds the element \ev\ at the top.
The container takes ownership over the element \ev.


\item \meth{void \st Chop(\st* \sv)}


Removes and destroys the top element of a non-empty container.
\emph{It is a run-time error to call this function on an empty container.}


\item \meth{int \st Contains(\st* \sv, \et\ \ev)}


Returns non-zero value if container \sv\ contains one or more elements considered equal to the specified element \ev\ and zero value otherwise.


\item \meth{\et\ \st Find(\st* \sv, \et\ \ev)}


Returns the first element considered equal to the specified element \ev.
\emph{It is a run-time error to call this function on a container which contains no such elements. Call the function \meth{\st Contains()} to check for their presence.}
The container retains ownership over returned element.


\item \meth{int \st Replace(\st* \sv, \et\ \ev)}


Replaces the first element of those contained in \sv, which is considered equal to the specified element \ev, with this element.
On successful replacement the container takes ownership over \ev.
The replaced element is destroyed.
Returns non-zero value on successful replacement (if there was such element) and zero value otherwise.
It it not an error for a container not to contain such element (in such a case the function will return zero).


\item \meth{int \st ReplaceAll(\st* \sv, \et\ \ev)}


Replaces all the elements of those contained in \sv, which are considered equal to the specified element \ev\ with this element.
On successful replacement the container takes ownership over \ev.
The replaced elements are destroyed.
Returns the number of elements replaced.
It it not an error for a container not to contain such elements (in such a case the function will return zero).


\end{itemize}


%----------------------------------------------------------------------------------------------------------------------


\newcommand{\Hashset}{\emph{HashSet}}
\section{\Hashset\ container}


%----------------------------------------------------------------------------------------------------------------------


\newcommand{\Hashmap}{\emph{HashMap}}
\section{\Hashmap\ container}


\end{document}