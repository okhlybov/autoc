\documentclass[a4paper]{article}


\clubpenalty=10000
\widowpenalty=10000


\usepackage{geometry}
\geometry{a4paper,margin=15mm,bindingoffset=15mm,heightrounded}


\usepackage{listings}
\lstloadlanguages{Ruby,C,C++,Java,bash}
\lstset{commentstyle=\itshape,stringstyle=\bfseries}


\usepackage{parskip}


\newcommand{\autoc}{\emph{AutoC}}


\newcommand{\R}{\emph{Ruby}}


\newcommand{\C}{\emph{C}}


\newcommand{\Cpp}{\emph{C++}}


\newcommand{\Java}{\emph{Java}}


\lstnewenvironment{rs}{\lstset{language=Ruby,frame=tlbr,basicstyle=\small}}{}


\lstnewenvironment{cs}{\lstset{language=C,frame=tlbr,basicstyle=\small}}{}


\lstnewenvironment{bs}{\lstset{language=bash,frame=tlbr,basicstyle=\small}}{}



\newcommand{\st}{\underline{type}}
\newcommand{\et}{\underline{element-type}}
\newcommand{\kt}{\underline{key-type}}
\newcommand{\vt}{\underline{value-type}}


\newcommand{\sv}{\emph{self}}
\newcommand{\ev}{\emph{element}}
\newcommand{\kv}{\emph{key}}
\newcommand{\vv}{\emph{value}}


\newcommand{\meth}[1]{#1}


\begin{document}


\title{\autoc\ user's manual}
\author{Oleg A. Khlybov}


\maketitle


\tableofcontents


\newpage


\part{Introduction}


\autoc\ is a host of \R\ modules related to automatic \C\ source code generation.


\newcommand{\codebuilder}{\emph{CodeBuilder}}
\part{\codebuilder\ module}


This module contains a facility to generate multi-file \C\ modules.


\newcommand{\datastructbuilder}{\emph{DataStructBuilder}}
\part{\datastructbuilder\ module}


This module contains generators which create strongly-typed \C\ data containers similar to those found in \Cpp\ \emph{STL} library: \emph{vector}, \emph{list}, \emph{set}, \emph{map}, and more.


\section{Quick start}


Suppose one needs a \C\ set container which operates on \lstinline[language=C++]{int} data type.
In \Cpp\ world this would be a \lstinline[language=C++]{std::set<int>} type (with the difference that \lstinline[language=C++]{std::set<>} is a tree-based set while \autoc\ currently contains generator for a hash-based set implementation only).


\begin{enumerate}


\item Create a \R\ definition file \emph{containers.rb}:


\begin{rs}
require "autoc"

Int = {:type=>"int"}

CodeBuilder::CModule.generate!("containers") do |m|
	m << DataStructBuilder::HashSet.new("IntSet", Int)
end
\end{rs}


The above file contains \R\ code which instructs to generate the set data structure \emph{IntSet} and put generated \C\ code into specific \C\ compilation unit named \emph{containers}.



\item Generate \C\ source files:


\lstinline[language=bash]!> ruby containers.rb!


Provided that \autoc\ files are somewhere in the \R\ path, the above command will output two \C\ files which consitiute the compilation unit \emph{containers}: the interface file \emph{containers\_auto.h} and the implementation file \emph{containers\_auto.c}.


\item Create main \C\ source file \emph{main.c}:


\begin{cs}
#include <stdio.h>

#include "containers_auto.h"

int main(int argc, char** argv) {
	IntSet set;
	IntSetCtor(&set);
	IntSetPut(&set, 0);
	IntSetPut(&set, 1);
	IntSetPut(&set, 0);
	printf("size(set)=%d\n", IntSetSize(&set));
	IntSetDtor(&set);
	return 0;
}
\end{cs}


The code above creates a set container \emph{set} on stack, puts three integer values into it, prints the number of elements the set actually contains and finally destroys the container.


\item Build the executable:


\lstinline[language=bash]!> cc -o runme main.c containers_auto.c!


On successful execution the above command will produce the executable \emph{runme} with defined logic.


\item Run the executable:


\lstinline[language=bash]!> runme!


Correct output for this program will be 
\begin{verbatim}
size(set)=2
\end{verbatim}
since the set rejects inclusion of duplicate values (in the above case it's \emph{0}).


\end{enumerate}


\section{\R-side operation}


In order to generate the appropriate \C\ source code a \R\ script is to be written.


\subsection{Type specification}


The custom type specification is supplied to the generator's constructor in form of a \emph{Hash}-like object.
It may be either \emph{Hash} instance or any other object responding to \lstinline[language=Ruby]![]! method.
\emph{Note that the generated data structures themselves can also be used as the elements of other data structures.}
This object contains the information regarding the \C-side type and function information in form of the sequence of associations \lstinline[language=Ruby]!{:key1=>value1, :key2=>value2, ...}!, for example \lstinline[language=Ruby]!{:type=>"const char*"}!. The keys must be the \R\ symbols while the associated values can be of any string-like type.
The hash might contain the following keys:


\begin{itemize}


\item \lstinline[language=Ruby]!:type!


A \emph{mandatory} key specifying the \C-side type declaration \st.


For example, \lstinline[language=Ruby]!:type=>"Box*"!.


\item \lstinline[language=Ruby]!:forward!


An optional key which presents an arbitrary \C\ code to be injected into the generated interface file \emph{before} any other type declarations.
This is useful for complex used-defined types, such as structs, which must be declared prior to the container's own declarations.


For example, \lstinline[language=Ruby]!:forward=>"typedef struct Box Box;"!.
Here an incomplete \C\ struct declaration is specified, which is sufficient if the generated data structure will operate on an opaque reference type (\lstinline[language=C]{Box*} in this case).
For complex used-defined value types a full type declaration must be specified.


If omitted, no code will be injected.


\item \lstinline[language=Ruby]!:ctor!


An optional key which presents a \C-side default parameterless type constructor.


The expected \C\ function signature is: \meth{\st\ \emph{function}(void)}.


The specified function is called whenever a new element is to be created within the data structure.


If omitted, no construction will be performed. This basically means that the way the storage of a newly created element is initialized will be data structure-specific. In most cases (but not neccessarily) it will be simply filled with zeroes.


\item \lstinline[language=Ruby]!:dtor!


An optional key which presents a \C-side type destructor.


The expected \C\ function signature is: \meth{void \emph{function}(\st)}.


The specified function is called whenever an element is removed from container or destroyed prior the destruction of the container itself.


If omitted, no destruction will be performed.


\item \lstinline[language=Ruby]!:assign!


An optional key which presents a \C-side copy constructor.


The expected \C\ function signature is: \meth{\st\ \emph{function}(\st)}.


The specified function is called whenever an element is passed into a container's method.
This applies not only to the elements which are to be taken over by container, but also to any other elements of this type which cross the function's body (temporary values, for example).
In the latter case, such elements will be released by calling the respective destructor on them prior exiting the function.


If omitted, the default value assignment expression using the \C\ assignment operator \emph{=} is generated.


\item \lstinline[language=Ruby]!:hash!


An optional key which presents a \C-side hashing function.
This function will be used by the hash-based data structures, \emph{HashSet} and \emph{HashMap}.


The expected \C\ function signature is: \meth{size\_t \emph{function}(\st)}.


If omitted, the hash value will be represented by the value cast to \emph{size\_t}.
\emph{Note that not all types can be automatically casted to an integer value resulting in a compile-time error.}
Specifically, this will work for numbers, chars, reference values, but not for structs.
In the latter case a custom hashing function must be provided.


\item \lstinline[language=Ruby]!:equal!


An optional key which presents a \C-side equality testing function.
This function is used by the data containers to test for equality of two elements.


The expected \C\ function signature is: \meth{int \emph{function}(\st, \st)}.


The function specified must return non-zero value if two elements are considered equal and zero value otherwise.


If omitted, a simple value comparison using the \C\ equality testing operator \lstinline[language=C]!==! is generated.


\end{itemize}


\subsection{Value types vs. reference types}


\subsection{Reference types with embedded reference counting}


A proposed way to deal with values passed by reference is to use embedded reference counting scheme as described below.
It worth noting that the generated data structures obey this scheme themselves allowing their reference values to be used as the elements for other data structures.


Each type is represented by a \C\ struct which embeds an integer reference count field:


\begin{cs}
typedef struct Box Box;
struct Box {
	size_t ref_count;
	...
};
\end{cs}


The type creation function allocates space sufficiently large to hold the struct, calls the respective initializing constructor and sets the initial reference count:


\begin{cs}
Box* BoxNew(...) {
	Box* box = (Box*)malloc(sizeof(Box));
	BoxCtor(box, ...);
	box->ref_count = 0;
	return box;
}
\end{cs}


The initial reference count is set to zero, meaning that the newly created value is unassigned (say, orphaned).
Hence it must be manually assigned to a local variable which will reference it.


\emph{This scheme allows for temporary values to be created and passed into functions which temporarily take ownership over the passed values and release them on exit. If this happens to be a value with no more other references exist outside the function, it will be automatically destroyed upon exit.}


The assignment function (also called copy constructor) simply passes through the specified reference value bumping up its reference count:
\begin{cs}
Box* BoxAssign(Box* self) {
	++self->ref_count;
	return self;
}
\end{cs}


The type destruction function decreases the reference count destroying the value and freeing the associated storage when the count hits zero:


\begin{cs}
void BoxDestroy(Box* self) {
	if(!--self->ref_count) {
		BoxDtor(self);
		free(self);
	}
}
\end{cs}


A general rule of thumb for the type above is to manually assign local variables as a part of their initialization process and destroy them upon going out of scope as illustrated by the code excerpt below:


\begin{cs}
BoxSet* set;
...
{
	Box* b = BoxAssign(BoxNew(...));
	...
	BoxSetContains(set, b);
	...
	BoxDestroy(b);
}
\end{cs}


As mentioned above, this scheme allows the temporary values to be passed to functions as follows:


\begin{cs}
BoxSet* set;
...
BoxSetContains(set, BoxNew(...));
\end{cs}


In the case above no assigned variable exists to the value created by the \meth{BoxNew()} hence it will be automatically destroyed upon the exit from \meth{BoxSetContains()}.


In the reverse case of obtaining a reference from a function the safest way is to call assign on its result:
\begin{cs}
BoxSet* set;
...
{
	Box* b = BoxAssign(BoxSetGet(box, ...));
	...
	BoxDestroy(b);
}
\end{cs}


This way the reference \emph{b} will remain valid up to the respective call to \meth{BoxDestroy()} even if the set \emph{set} gets destroyed along the way before \emph{b} goes out of scope.


On the final note, for the case described above the \R-side type specification will be:


\begin{rs}
{
	:type=>"Box*",
	:forward=>"typedef struct Box Box;",
	:assign=>"BoxAssign",
	:dtor=>"BoxDestroy",
	...
}
\end{rs}


\subsection{Hash-based data structures}


\section{Generated \C\ code}


\newcommand{\commonmethods}{


\item \meth{void \st Dtor(\st*\ \sv)}


Destroys the container along with all contained elements.


\item \meth{void \st Destroy(\st* \sv)}


Frees the heap-allocated container destroying all contained elements.
Calls the respective destructor \meth{\st Dtor()} behind the scenes.


\item \meth{\st* \st Assign(\st* \sv)}


\emph{Should be called on heap-allocated containers only.}


\item \meth{size\_t \st Size(\st* \sv)}


Returns the number of elements in container.

	
}


\subsection{Naming conventions}


Every generated data container named \emph{type} on the \C\ side comprises of the opaque \C\ struct named \emph{type} (referred to as \st\ in this manual) accompanied by a number of \C\ functions with their names prefxed by \emph{type}, which define a set operations on that data container.
For example, a set of integers named \emph{IntSet} will be represented by the generated \C\ struct \lstinline[language=C]!struct IntSet {...}! and \C\ functions \lstinline[language=C]!void IntSetCtor(...)!, \lstinline[language=C]!void IntSetDtor(...)! etc.

The data container's \C\ element type for all data structures but the mapping will be referred to as \et, the key type and the value type for the mapping will be referred to as \kt\ and \vt, respectively.


\subsection{Construction and destruction}


A data container may be created either on stack or in heap.
For the former case, a construction/destruction is performed by a \meth{\st Ctor()} / \meth{\st Dtor()} pair of functions while for the latter its \meth{\st New()} / \meth{\st Destroy()}.
There may be additional container-specific constructors described in the respective sections.

All generated data structures are reference-counted when allocated on heap.
This means that the pointers may be aliased, passed in and out of functions etc.


\subsection{Iteration}


All generated data structures have built-in iteration capability.
The \autoc's iterators are modeled after the \Java's iterators.
The current implementation is fairly simple and is not designed for the iterator objects to be passed around, shared etc.
Moreover, the data structures \emph{must not} be modified or destroyed from within the iteration loop.
While alterations of some data structures (notably lists) are known not to invalidate the active iterators, this does not hold true in general and must be avoided.


The code snippet below demonstrates the typical iterator usage scenario:

\begin{cs}
...
IntSetIt it;
IntSetItCtor(&it, &set);
while(IntSetItHasNext(&it)) {
	int value = IntSetItNext(&it);
	...
}
...
\end{cs}


The usual considerations apply to the order the iterated elements come in: vectors, lists and queues are ordered containers while sets and maps are not.


\subsection{Thread safety}


As of now, no effort is made to make the generated data structures thread-safe.
Hence, care must be taken when using there structures in multithreaded environment.


%----------------------------------------------------------------------------------------------------------------------


\newcommand{\Vector}{\emph{Vector}}
\section{\Vector\ container}


\Vector\ data structure is a simple 0-based resizable array similar to the \Cpp's \lstinline[language=C++]{std::vector<>}.


\subsection{\Vector\ interface}


\begin{itemize}


\item \meth{void \st Ctor(\st*\ \sv, size\_t \emph{size})}


Constructs the container with \emph{size} elements.
The valid index range will be [0, \emph{size}).
The elements are initialized with default constructor.


\item \meth{\st* \st New(size\_t \emph{size})}


Returns a new heap-allocated container constructed with \meth{\st Ctor()}.


\commonmethods


\item \meth{int \st Within(\st* \sv, size\_t \emph{index})}


Returns non-zero value when \emph{index} is a valid index, that is \emph{index} $\in$ [0, \meth{\st Size(\sv)}), and zero value otherwise.


\item \meth{void \st Resize(\st* \sv, size\_t \emph{new\_size})}


Resizes the container to have a new size \emph{new\_size}.
The new size may be either larger or smaller than the old one.
Upon resizing the extra elements which to not fall into new valid range [0, \emph{new\_size}) are destroyed and the missing elements are created with default constructor.


\item \meth{\et\ \st Get(\st* \sv, size\_t \emph{index})}


Returns the element contained at the valid index \emph{index} without releasing it (that is, the element returned will still be owned by the container).
\emph{It is a run-time error to get value at the index outside valid range.}


\item \meth{void \st Set(\st* \sv, size\_t \emph{index}, \et\ \ev)}


Sets the new value \ev\ at the valid index \emph{index}.
\emph{It is a run-time error to set value at the index outside valid range.}
The previously contained element at that index is destroyed.
The container takes ownership over the element \ev.


\end{itemize}



%----------------------------------------------------------------------------------------------------------------------


\newcommand{\List}{\emph{List}}
\section{\List\ container}


\List\ data structure is a singly-linked list which supports insertion and removal operations at one end similar to the \Cpp's recently standartized \lstinline[language=C++]{std::forward_list<>} class.


\subsection{\List\ interface}


\begin{itemize}


\item \meth{void \st Ctor(\st*\ \sv)}


Constructs empty container.


\item \meth{\st* \st New(void)}


Returns a new heap-allocated container constructed with \meth{\st Ctor()}.


\commonmethods


\item \meth{void \st Purge}(\st* \sv)


Removes and destroys all contained elements effectively emptying the container.


\item \meth{int \st Empty}(\st* \sv)


Returns non-zero value if container is empty (i.e. contains no elements) and zero value otherwise.


\item \meth{\et\ \st Get(\st* \sv)}


Returns top element of a non-empty container (i.e. the last one added according to the \emph{LIFO} concept).
\emph{It is a run-time error to get top element of an empty container.}
Container retains the ownership over the element returned.


\item \meth{void \st Add(\st* \sv, \et\ \ev)}


Adds the element \ev\ at the top.
The container takes ownership over the element \ev.


\item \meth{void \st Chop(\st* \sv)}


Removes and destroys the top element of a non-empty container.
\emph{It is a run-time error to call this function on an empty container.}


\item \meth{int \st Contains(\st* \sv, \et\ \ev)}


Returns non-zero value if container \sv\ contains one or more elements considered equal to the specified element \ev\ and zero value otherwise.


\item \meth{\et\ \st Find(\st* \sv, \et\ \ev)}


Returns the first element considered equal to the specified element \ev.
\emph{It is a run-time error to call this function on a container which contains no such elements. Call the function \meth{\st Contains()} to check for their presence.}
The container retains ownership over returned element.


\item \meth{int \st Replace(\st* \sv, \et\ \ev)}


Replaces the first element of those contained in \sv, which is considered equal to the specified element \ev, with this element.
On successful replacement the container takes ownership over \ev.
The replaced element is destroyed.
Returns non-zero value on successful replacement (if there was such element) and zero value otherwise.
It it not an error for a container not to contain such element (in such a case the function will return zero).


\item \meth{int \st ReplaceAll(\st* \sv, \et\ \ev)}


Replaces all the elements of those contained in \sv\ which are considered equal to the specified element \ev\ with this element.
On successful replacement the container takes ownership over \ev.
The replaced elements are destroyed.
Returns the number of elements replaced.
It it not an error for a container to contain no such elements (in such a case the function will return zero).


\item \meth{int \st Remove(\st* \sv, \et\ \ev)}


Removes and destroys the first element of those contained in \sv\ which is considered equal to the specified element \ev.
Returns non-zero value on successful removal (if there was such element) and zero value otherwise.
It it not an error for a container not to contain such element (in such a case the function will return zero).


\item \meth{int \st RemoveAll(\st* \sv, \et\ \ev)}


Removes and destroys all elements of those contained in \sv\ which are considered equal to the specified element \ev.
Returns the number of elements removed.
It it not an error for a container to contain no such elements (in such a case the function will return zero).


\end{itemize}


%----------------------------------------------------------------------------------------------------------------------


\newcommand{\Queue}{\emph{Queue}}
\section{\Queue\ container}


\Queue\ data structure is a doubly-linked list which supports insertion and removal operations at both ends similar to the \Cpp's \lstinline[language=C++]{std::list<>} or the \Java's \lstinline[language=Java]{java.util.LinkedList<>} classes.


\subsection{\Queue\ interface}


\begin{itemize}


\item \meth{void \st Ctor(\st*\ \sv)}


Constructs empty container.


\item \meth{\st* \st New(void)}


Returns a new heap-allocated container constructed with \meth{\st Ctor()}.


\commonmethods


\item \meth{void \st Purge}(\st* \sv)


Removes and destroys all contained elements effectively emptying the container.


\item \meth{int \st Empty}(\st* \sv)


Returns non-zero value if container is empty (i.e. contains no elements) and zero value otherwise.


\item \meth{\et\ \st Head(\st* \sv)}


Returns head (first) element of a non-empty container.
\emph{It is a run-time error to get top element of an empty container.}
Container retains the ownership over the element returned.


\item \meth{\et\ \st Tail(\st* \sv)}


Returns tail (last) element of a non-empty container.
\emph{It is a run-time error to get top element of an empty container.}
Container retains the ownership over the element returned.


\item \meth{void \st Append(\st* \sv, \et\ \ev)}


Adds the element \ev\ at the queue's tail.
The added element becomes the last in the queue.
The container takes ownership over the element \ev.


\item \meth{void \st Prepend(\st* \sv, \et\ \ev)}


Adds the element \ev\ at the queue's head.
The added element becomes the first in the queue.
The container takes ownership over the element \ev.


\item \meth{void \st ChopHead(\st* \sv)}


Removes and destroys the head element of a non-empty container.
\emph{It is a run-time error to call this function on an empty container.}


\item \meth{void \st ChopTail(\st* \sv)}


Removes and destroys the tail element of a non-empty container.
\emph{It is a run-time error to call this function on an empty container.}


\item \meth{int \st Contains(\st* \sv, \et\ \ev)}


Returns non-zero value if container \sv\ contains one or more elements considered equal to the specified element \ev\ and zero value otherwise.


\item \meth{\et\ \st Find(\st* \sv, \et\ \ev)}


Returns the first element considered equal to the specified element \ev.
\emph{It is a run-time error to call this function on a container which contains no such elements. Call the function \meth{\st Contains()} to check for their presence.}
The container retains ownership over returned element.


\item \meth{int \st Replace(\st* \sv, \et\ \ev)}


Replaces the first element of those contained in \sv, which is considered equal to the specified element \ev, with this element.
On successful replacement the container takes ownership over \ev.
The replaced element is destroyed.
Returns non-zero value on successful replacement (if there was such element) and zero value otherwise.
It it not an error for a container not to contain such element (in such a case the function will return zero).


\item \meth{int \st ReplaceAll(\st* \sv, \et\ \ev)}


Replaces all the elements of those contained in \sv\ which are considered equal to the specified element \ev\ with this element.
On successful replacement the container takes ownership over \ev.
The replaced elements are destroyed.
Returns the number of elements replaced.
It it not an error for a container to contain no such elements (in such a case the function will return zero).


\item \meth{int \st Remove(\st* \sv, \et\ \ev)}


Removes and destroys the first element of those contained in \sv\ which is considered equal to the specified element \ev.
Returns non-zero value on successful removal (if there was such element) and zero value otherwise.
It it not an error for a container not to contain such element (in such a case the function will return zero).


\item \meth{int \st RemoveAll(\st* \sv, \et\ \ev)}


Removes and destroys all elements of those contained in \sv\ which are considered equal to the specified element \ev.
Returns the number of elements removed.
It it not an error for a container to contain no such elements (in such a case the function will return zero).


\end{itemize}


%----------------------------------------------------------------------------------------------------------------------


\newcommand{\Hashset}{\emph{HashSet}}
\section{\Hashset\ container}


\Hashset\ data structure is a hashed set similar to the \Cpp's recently standartized \lstinline[language=C++]{std::unordered_set<>} or the \Java's \lstinline[language=Java]{java.util.HashSet<>} classes.
Current implementation provides automatic capacity management.


\subsection{\Hashset\ interface}


\begin{itemize}


\item \meth{void \st Ctor(\st*\ \sv)}


Constructs empty container.


\item \meth{\st* \st New(void)}


Returns a new heap-allocated container constructed with \meth{\st Ctor()}.


\commonmethods


\item \meth{void \st Purge}(\st* \sv)


Removes and destroys all contained elements effectively emptying the container.


\item \meth{int \st Empty}(\st* \sv)


Returns non-zero value if container is empty (i.e. contains no elements) and zero value otherwise.


\item \meth{void \st Rehash(\st* \sv)}


Casuses the container to change its capacity according to the number of currently contained elements to stay within the optimal range.
This function does nothing if current capacity is within optimal range.
\emph{There is no need to call this function manually as rehashing is done automatically.}


\item \meth{int \st Contains(\st* \sv, \et\ \ev)}


Returns non-zero value if container \sv\ contains an element considered equal to the specified element \ev\ and zero value otherwise.


\item \meth{\et\ \st Get(\st* \sv, \et\ \ev)}


Returns the element of those contained in \sv, which is considered equal to the specified element \ev.
\emph{It is a run-time error to call this function on a container which contains no such element. Call the function \meth{\st Contains()} to check for its presence.}
Container retains ownership over the element returned.


\item \meth{int \st Put(\st* \sv, \et\ \ev)}


Puts element \ev\ into container if there is no other element already contained \sv\ which is considered equal to the element specified.
Returns non-zero value on successful addition or zero value when the element is already present.
In case of successful addition the container takes ownership over \ev.


\item \meth{void \st Replace(\st* \sv, \et\ \ev)}


Replaces the element of those contained in \sv, which is considered equal to the specified element \ev, with this element or simply puts the specified element into container if no such element was found.
In either case the container takes ownership over \ev.
On successful replacement the replaced element is destroyed.


\item \meth{void \st Remove(\st* \sv, \et\ \ev)}


Removes and destroys the element of those contained in \sv\ which is considered equal to the specified element \ev.
Returns non-zero value on successful removal (if there was such element) and zero value otherwise.
It it not an error for a container not to contain such element (in such a case the function will return zero).


\end{itemize}


%----------------------------------------------------------------------------------------------------------------------


\newcommand{\Hashmap}{\emph{HashMap}}
\section{\Hashmap\ container}


\Hashmap\ data structure is a hashed map similar to the \Cpp's recently standartized \lstinline[language=C++]{std::unordered_map<>} or the \Java's \lstinline[language=Java]{java.util.HashMap<>} classes.
Current implementation provides automatic capacity management.


\subsection{\Hashmap\ interface}


\begin{itemize}


\item \meth{void \st Ctor(\st*\ \sv)}


Constructs empty container.


\item \meth{\st* \st New(void)}


Returns a new heap-allocated container constructed with \meth{\st Ctor()}.


\commonmethods


\item \meth{void \st Purge}(\st* \sv)


Removes and destroys all contained entries effectively emptying the container.


\item \meth{int \st Empty}(\st* \sv)


Returns non-zero value if container is empty (i.e. contains no elements) and zero value otherwise.


\item \meth{void \st Rehash(\st* \sv)}


Casuses the container to change its capacity according to the number of currently contained elements to stay within the optimal range.
This function does nothing if current capacity is within optimal range.
\emph{There is no need to call this function manually as rehashing is done automatically.}


\item \meth{int \st ContainsKey(\st* \sv, \kt\ \kv)}


Returns non-zero value if container \sv\ contains an entry with the key considered equal to the specified key \kv\ and zero value otherwise.


\item \meth{\vt\ \st Get(\st* \sv, \kt\ \kv)}


Returns value associated with the key considered equal to the specified key \kv.
\emph{It is a run-time error to call this function on a container which contains no entry with such a key. Call the function \meth{\st ContainsKey()} to check for its presence.}
Container retains ownership over the value returned.


\item \meth{int \st Put(\st* \sv, \kt\ \kv, \vt\ \vv)}


Associates the specified value \vv\ with the specified key \kv\ and puts it into container if there exist no entry with the key considered equal to the specified key.
Returns non-zero value on successful addition or zero value when such entry is already present.
In any case the container takes ownership over \vv; the ownership over \kv\ is taken on successful addition only.


\item \meth{void \st Replace(\st* \sv, \kt\ \kv, \vt\ \vv)}


Replaces a value associated with the key considered equal to the specified key \kv with the specified value \vv if such key exists otherwise simply puts the new \kv$\rightarrow$\vv\ association into container.
In any case the container takes ownership over \vv; the ownership over \kv\ is taken on successful replacement only.
On successful replacement the replaced value is destroyed.


\item \meth{void \st Remove(\st* \sv, \kt\ \kv)}


Removes the association \kv$\rightarrow$\vv\ of those contained in \sv\ with the key considered equal to the specified key \kv. 
Returns non-zero value on successful removal (if there was such entry) and zero value otherwise.
On successful removal both key and value are destroyed.
It it not an error for a container not to contain \kv\ (in such a case the function will return zero).


\end{itemize}


\end{document}