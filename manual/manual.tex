\documentclass[a4paper]{article}


\clubpenalty=10000
\widowpenalty=10000


\usepackage{geometry}
\geometry{a4paper,margin=15mm,bindingoffset=15mm,heightrounded}


\usepackage{listings}
\lstloadlanguages{Ruby,C,C++,Java,bash}
\lstset{commentstyle=\itshape,stringstyle=\bfseries}


\newcommand{\autoc}{\emph{AutoC}}


\newcommand{\R}{\emph{Ruby}}


\newcommand{\C}{\emph{C}}


\newcommand{\Cpp}{\emph{C++}}


\newcommand{\Java}{\emph{Java}}


\lstnewenvironment{rs}{\lstset{language=Ruby,frame=tlbr,basicstyle=\small}}{}


\lstnewenvironment{cs}{\lstset{language=C,frame=tlbr,basicstyle=\small}}{}


\lstnewenvironment{bs}{\lstset{language=bash,frame=tlbr,basicstyle=\small}}{}



\newcommand{\st}{\underline{type}}
\newcommand{\et}{\underline{element-type}}
\newcommand{\kt}{\underline{key-type}}
\newcommand{\vt}{\underline{value-type}}


\newcommand{\sv}{\emph{self}}
\newcommand{\ev}{\emph{element}}
\newcommand{\kv}{\emph{key}}
\newcommand{\vv}{\emph{value}}


\newcommand{\meth}[1]{#1}


\begin{document}


\title{\autoc\ user's manual}
\author{Oleg A. Khlybov}


\maketitle


\part{Introduction}


\autoc\ is a host of \R\ modules related to automatic \C\ source code generation.


\newcommand{\codebuilder}{\emph{CodeBuilder}}
\part{\codebuilder\ module}


This module contains a facility to help generate \C\ modules.


\newcommand{\datastructbuilder}{\emph{DataStructBuilder}}
\part{\datastructbuilder\ module}


This module contains generators which create strongly-typed \C\ data containers similar to those found in \Cpp\ \emph{STL} library: \emph{vector}, \emph{list}, \emph{set}, \emph{map}, and more.


\section{Quick start}


Suppose one needs a \C\ set container which operates on \lstinline[language=C++]{int} data type.
In \Cpp\ world this would be a \lstinline[language=C++]{std::set<int>} type (with the difference that \lstinline[language=C++]{std::set<>} is a tree-based set while \autoc\ currently contains generator for a hash-based set implementation only).


\begin{enumerate}


\item Create a \R\ definition file \emph{containers.rb}:


\begin{rs}
require "autoc"

Int = {:type=>"int"}

CodeBuilder::CModule.generate!("containers") do |m|
	m << DataStructBuilder::HashSet.new("IntSet", Int)
end
\end{rs}


The above file contains \R\ code which instructs to generate the set data structure \emph{IntSet} and put generated \C\ code into specific \C\ compilation unit named \emph{containers}.



\item Generate \C\ source files:


\lstinline[language=bash]!> ruby containers.rb!


Provided that \autoc\ files are somewhere in the \R\ path, the above command will output two \C\ files which consitiute the compilation unit \emph{containers}: the interface file \emph{containers\_auto.h} and the implementation file \emph{containers\_auto.c}.


\item Create main \C\ source file \emph{main.c}:


\begin{cs}
#include <stdio.h>

#include "containers_auto.h"

int main(int argc, char** argv) {
	IntSet set;
	IntSetCtor(&set);
	IntSetPut(&set, 0);
	IntSetPut(&set, 1);
	IntSetPut(&set, 0);
	printf("size(set)=%d\n", IntSetSize(&set));
	IntSetDtor(&set);
	return 0;
}
\end{cs}


The code above creates a set container \emph{set} on stack, puts three integer values into it, prints the number of elements the set actually contains and finally destroys the container.


\item Build the executable:


\lstinline[language=bash]!> cc -o runme main.c containers_auto.c!


On successful execution the above command will produce the executable \emph{runme} with defined logic.


\item Run the executable:


\lstinline[language=bash]!> runme!


Correct output for this program will be 
\begin{verbatim}
size(set)=2
\end{verbatim}
since the set rejects inclusion of duplicate values (in the above case it's \emph{0}).


\end{enumerate}


\section{Generated \C\ code}


\newcommand{\commonmethods}{


\item \meth{void \st Dtor(\st*\ \sv)}


Destroys the container along with all contained elements.


\item \meth{\st* \st New(size\_t \emph{size})}


Returns a new heap-allocated container constructed with \meth{\st Ctor()}.


\item \meth{void \st Destroy(\st* \sv)}


Frees the heap-allocated container destroying all contained elements.


\item \meth{\st* \st Assign(\st* \sv)}


\emph{Should be called on heap-allocated containers only.}


\item \meth{size\_t \st Size(\st* \sv)}


Returns the number of elements in container.

	
}


\subsection{Naming conventions}


Every generated data container named \emph{type} on the \C\ side comprises of the opaque \C\ struct named \emph{type} (referred to as \st\ in this manual) accompanied by a number of \C\ functions with their names prefxed by \emph{type}, which define a set operations on that data container.
For example, a set of integers named \emph{IntSet} will be represented by the generated \C\ struct \lstinline[language=C]!struct IntSet {...}! and \C\ functions \lstinline[language=C]!void IntSetCtor(...)!, \lstinline[language=C]!void IntSetDtor(...)! etc.

The data container's \C\ element type for all data structures but the mapping will be referred to as \et, the key type and the value type for the mapping will be referred to as \kt\ and \vt, respectively.


\subsection{Construction and destruction}


A data container may be created either on stack or in heap.
For the former case, a construction/destruction is performed by a \meth{\st Ctor()} / \meth{\st Dtor()} pair of functions while for the latter its \meth{\st New()} / \meth{\st Destroy()}.
There may be additional container-specific constructors described in the respective sections.

All generated data structures are reference-counted when allocated on heap.
This means that the pointers may be aliased, passed in and out of functions etc.


\subsection{Iteration}


All generated data structures have built-in iteration capability.
The \autoc's iterators are modeled after the \Java's iterators.
The current implementation is fairly simple and is not designed for the iterator objects to be passed around, shared etc.
Moreover, the data structures \emph{must not} be modified or destroyed from within the iteration loop.
While alterations of some data structures (notably \emph{lists}) are known not to invalidate the active iterators, this does not hold true in general and must be avoided.


The code snippet below demonstrates the typical iterator usage scenario:

\begin{cs}
...
IntSetIt it;
IntSetItCtor(&it, &set);
while(IntSetItHasNext(&it)) {
	int value = IntSetItNext(&it);
	...
}
...
\end{cs}


The usual considerations apply to the order the iterated elements come in: \emph{vectors} and \emph{lists} are the ordered containers while \emph{sets} and \emph{maps} are not.


\subsection{Thread safety}


As for now, no effort is made to make the generated data structures thread-safe.
Hence, care must be taken when using there structures in multithreaded environment.


%----------------------------------------------------------------------------------------------------------------------


\newcommand{\Vector}{\emph{Vector}}
\section{\Vector\ container}


\Vector\ data structure is a simple 0-based resizable array similar to the \Cpp's \lstinline[language=C++]{std::vector<>}.


\subsection{\Vector\ interface}


\begin{itemize}


\item \meth{void \st Ctor(\st*\ \sv, size\_t \emph{size})}


Constructs the container with \emph{size} elements.
The valid index range will be [0, \emph{size}).
The elements are initialized with default constructor.


\commonmethods


\item \meth{int \st Within(\st* \sv, size\_t \emph{index})}


Returns non-zero value when \emph{index} is a valid index, that is \emph{index} $\in$ [0, \meth{\st Size(\sv)}), and zero value otherwise.


\item \meth{void \st Resize(\st* \sv, size\_t \emph{new\_size})}


Resizes the container to have a new size \emph{new\_size}.
The new size may be either larger or smaller than the old one.
Upon resizing the extra elements which to not fall into new valid range [0, \emph{new\_size}) are destroyed and the missing elements are created with default constructor.


\item \meth{\et\ \st Get(\st* \sv, size\_t \emph{index})}


Returns the element contained at the valid index \emph{index} without releasing it (that is, the element returned will still be owned by the container).
\emph{It is a run-time error to get value at the index outside valid range.}


\item \meth{void \st Set(\st* \sv, size\_t \emph{index}, \et\ \ev)}


Sets the new value \ev\ at the valid index \emph{index}.
\emph{It is a run-time error to set value at the index outside valid range.}
The previously contained element at that index is destroyed.
The container takes ownership over the element \ev.


\end{itemize}



%----------------------------------------------------------------------------------------------------------------------


\newcommand{\List}{\emph{List}}
\section{\List\ container}


\List\ data structure is a singly-linked list which supports insertion and removal operations at one end in a manner of the \Java's \lstinline[language=Java]{java.util.LinkedList<>} class.


\subsection{\List\ interface}


\begin{itemize}


\item \meth{void \st Ctor(\st*\ \sv)}


Constructs empty container.


\commonmethods


\item \meth{void \st Purge}(\st* \sv)


Removes and destroys all contained elements effectively emptying the container.


\item \meth{int \st Empty}(\st* \sv)


Returns non-zero value if container is empty (i.e. contains no elements) and zero value otherwise.


\item \meth{\et\ \st Get(\st* \sv)}


Returns top element of a non-empty container (i.e. the last one added according to the \emph{LIFO} concept).
\emph{It is a run-time error to get top element of an empty container.}
Container retains the ownership over the element returned.


\item \meth{void \st Add(\st* \sv, \et\ \ev)}


Adds the element \ev\ at the top.
The container takes ownership over the element \ev.


\item \meth{void \st Chop(\st* \sv)}


Removes and destroys the top element of a non-empty container.
\emph{It is a run-time error to call this function on an empty container.}


\item \meth{int \st Contains(\st* \sv, \et\ \ev)}


Returns non-zero value if container \sv\ contains one or more elements considered equal to the specified element \ev\ and zero value otherwise.


\item \meth{\et\ \st Find(\st* \sv, \et\ \ev)}


Returns the first element considered equal to the specified element \ev.
\emph{It is a run-time error to call this function on a container which contains no such elements. Call the function \meth{\st Contains()} to check for their presence.}
The container retains ownership over returned element.


\item \meth{int \st Replace(\st* \sv, \et\ \ev)}


Replaces the first element of those contained in \sv, which is considered equal to the specified element \ev, with this element.
On successful replacement the container takes ownership over \ev.
The replaced element is destroyed.
Returns non-zero value on successful replacement (if there was such element) and zero value otherwise.
It it not an error for a container not to contain such element (in such a case the function will return zero).


\item \meth{int \st ReplaceAll(\st* \sv, \et\ \ev)}


Replaces all the elements of those contained in \sv\ which are considered equal to the specified element \ev\ with this element.
On successful replacement the container takes ownership over \ev.
The replaced elements are destroyed.
Returns the number of elements replaced.
It it not an error for a container to contain no such elements (in such a case the function will return zero).


\item \meth{int \st Remove(\st* \sv, \et\ \ev)}


Removes and destroys the first element of those contained in \sv\ which is considered equal to the specified element \ev.
Returns non-zero value on successful removal (if there was such element) and zero value otherwise.
It it not an error for a container not to contain such element (in such a case the function will return zero).


\item \meth{int \st RemoveAll(\st* \sv, \et\ \ev)}


Removes and destroys all elements of those contained in \sv\ which are considered equal to the specified element \ev.
Returns the number of elements removed.
It it not an error for a container to contain no such elements (in such a case the function will return zero).


\end{itemize}


%----------------------------------------------------------------------------------------------------------------------


\newcommand{\Hashset}{\emph{HashSet}}
\section{\Hashset\ container}


\Hashset\ data structure is a hashed set similar to the \Cpp's recently standartized \lstinline[language=C++]{std::unordered_set<>} or the \Java's \lstinline[language=Java]{java.util.HashSet<>} classes.
Current implementation provides automatic capacity management.


\subsection{\Hashset\ interface}


\begin{itemize}


\item \meth{void \st Ctor(\st*\ \sv)}


Constructs empty container.


\commonmethods


\item \meth{void \st Purge}(\st* \sv)


Removes and destroys all contained elements effectively emptying the container.


\item \meth{int \st Empty}(\st* \sv)


Returns non-zero value if container is empty (i.e. contains no elements) and zero value otherwise.


\item \meth{void \st Rehash(\st* \sv)}


Casuses the container to change its capacity according to the number of currently contained elements to stay within the optimal range.
This function does nothing if current capacity is within optimal range.
\emph{There is no need to call this function manually as rehashing is done automatically.}


\item \meth{int \st Contains(\st* \sv, \et\ \ev)}


Returns non-zero value if container \sv\ contains an element considered equal to the specified element \ev\ and zero value otherwise.


\item \meth{\et\ \st Get(\st* \sv, \et\ \ev)}


Returns the element of those contained in \sv, which is considered equal to the specified element \ev.
\emph{It is a run-time error to call this function on a container which contains no such element. Call the function \meth{\st Contains()} to check for its presence.}
Container retains ownership over the element returned.


\item \meth{int \st Put(\st* \sv, \et\ \ev)}


Puts element \ev\ into container if there is no other element already contained \sv\ which is considered equal to the element specified.
Returns non-zero value on successful addition or zero value when the element is already present.
In case of successful addition the container takes ownership over \ev.


\item \meth{void \st Replace(\st* \sv, \et\ \ev)}


Replaces the element of those contained in \sv, which is considered equal to the specified element \ev, with this element or simply puts the specified element into container if no such element was found.
In either case the container takes ownership over \ev.
On successful replacement the replaced element is destroyed.


\item \meth{void \st Remove(\st* \sv, \et\ \ev)}


Removes and destroys the element of those contained in \sv\ which is considered equal to the specified element \ev.
Returns non-zero value on successful removal (if there was such element) and zero value otherwise.
It it not an error for a container not to contain such element (in such a case the function will return zero).


\end{itemize}


%----------------------------------------------------------------------------------------------------------------------


\newcommand{\Hashmap}{\emph{HashMap}}
\section{\Hashmap\ container}


\Hashmap\ data structure is a hashed map similar to the \Cpp's recently standartized \lstinline[language=C++]{std::unordered_map<>} or the \Java's \lstinline[language=Java]{java.util.HashMap<>} classes.
Current implementation provides automatic capacity management.


\subsection{\Hashmap\ interface}


\begin{itemize}


\item \meth{void \st Ctor(\st*\ \sv)}


Constructs empty container.


\commonmethods


\item \meth{void \st Purge}(\st* \sv)


Removes and destroys all contained entries effectively emptying the container.


\item \meth{int \st Empty}(\st* \sv)


Returns non-zero value if container is empty (i.e. contains no elements) and zero value otherwise.


\item \meth{void \st Rehash(\st* \sv)}


Casuses the container to change its capacity according to the number of currently contained elements to stay within the optimal range.
This function does nothing if current capacity is within optimal range.
\emph{There is no need to call this function manually as rehashing is done automatically.}


\item \meth{int \st ContainsKey(\st* \sv, \kt\ \kv)}


Returns non-zero value if container \sv\ contains an entry with the key considered equal to the specified key \kv\ and zero value otherwise.


\item \meth{\vt\ \st Get(\st* \sv, \kt\ \kv)}


Returns value associated with the key considered equal to the specified key \kv.
\emph{It is a run-time error to call this function on a container which contains no entry with such a key. Call the function \meth{\st ContainsKey()} to check for its presence.}
Container retains ownership over the value returned.


\item \meth{int \st Put(\st* \sv, \kt\ \kv, \vt\ \vv)}


Associates the specified value \vv\ with the specified key \kv\ and puts it into container if there exist no entry with the key considered equal to the specified key.
Returns non-zero value on successful addition or zero value when such entry is already present.
In any case the container takes ownership over \vv; the ownership over \kv\ is taken on successful addition only.


\item \meth{void \st Replace(\st* \sv, \kt\ \kv, \vt\ \vv)}


Replaces a value associated with the key considered equal to the specified key \kv with the specified value \vv if such key exists otherwise simply puts the new \kv$\rightarrow$\vv\ association into container.
In any case the container takes ownership over \vv; the ownership over \kv\ is taken on successful replacement only.
On successful replacement the replaced value is destroyed.


\item \meth{void \st Remove(\st* \sv, \kt\ \kv)}


Removes the association \kv$\rightarrow$\vv\ of those contained in \sv\ with the key considered equal to the specified key \kv. 
Returns non-zero value on successful removal (if there was such entry) and zero value otherwise.
On successful removal both key and value are destroyed.
It it not an error for a container not to contain \kv (in such a case the function will return zero).


\end{itemize}


\end{document}